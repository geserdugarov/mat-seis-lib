%% *plotUncRD*
% Compute the uncertainty ellipsoids and plot RMS time misfits in the [radial distance, depth]-plane

%%
% *Input:*

% fig             - [scalar] number of an existing figure
% figPosition     - [4, 1] vector specified the figure position and size
% figTitle        - [string] figure 'title' 
% figXlabel       - [string] figure 'xlabel'
% figYlabel       - [string] figure 'ylabel'
% figFontSize     - [scalar] font size
% timeRes         - [:, :] array of time residuals computed on a grid 
% timeResMax      - [scalar] maximum displayed time residual
% xSou            - [:, :] array of x-coordinates of the source grid
% ySou            - [:, :] array of y-coordinates of the source grid
% zSou            - [:, :] array of z-coordinates of the source grid
% units           - the unit structure generated by function 'setUnits'
% azimSou         - [scalar] source azimuth from East to North
% azimSouStd      - [scalar] standard deviation of the source azimuth 
% xRec            - [3, :] array of receiver coordinates
% plotRecFlag     - [scalar] flag, equal to 1 or 0, to indicate whether to plot the receivers 
% xWell           - [2, 1] lateral coordinates of the well location
% plotWellFlag    - [scalar] flag, equal to 1 or 0, to indicate whether to plot the well
%                   trajectory 
% isou            - [scalar] source number for which computations are performed
% indexPerf       - [1, size(sou, 2)] array of the indexes of perforation shots specified in
%                   function 'setSouRec'
% markerSizePerf  - [scalar] marker size for perforation shots 
% markerColorPerf - [1, 3] color array for perforation shots
% indexEvnt       - [1, size(sou, 2)] array of the indexes of microseismic events specified in
%                   function 'setSouRec'
% markerSizeEvnt  - [scalar] marker size for microseismic events
% markerColorEvnt - [1, 3] color array for microseismic events
% markerSizeRec   - [scalar] marker size for receivers
% markerColorRec  - [1, 3] color array for receivers
% plotIntFlag     - [scalar] flag, equal to 1 or 0, to indicate whether to plot interfaces
% interface       - [5, :] array of interfaces specified in 'setInterface'  
% colorInt        - [1, 3] color array for interfaces

%%
% *Output:*

% x0Unc           - [3, 1] coordinates of the center of the uncertainty ellipsoid  
% AUnc            - [3, 3] symmetric positive definite matrix describing the ellipsoid 
%                   in the form (x - x0Unc)'*AUnc*(x - x0Unc) = 1
% vUnc            - [3, 3] eigenvector matrix of the uncertainty ellipsoid
% dUnc            - [3, 1] vector of eigenvalues (or semi-axes) of the ellipsoid

%%
% *Author:* Vladimir Grechka 2012

%%
function [x0Unc, AUnc, vUnc, dUnc] = ...
   plotUncRD(fig, figPosition, figTitle, figXlabel, figYlabel, figFontSize, ...
             timeRes, timeResMax, xSou, ySou, zSou, units, azimSou, azimSouStd, ...
             xRec, plotRecFlag, xWell, plotWellFlag,  isou, ... 
             indexPerf, markerSizePerf, markerColorPerf, ...
             indexEvnt, markerSizeEvnt, markerColorEvnt, ...
             markerSizeRec, markerColorRec, colorEllipse, ...
             plotIntFlag, interface, colorInt)
%% Settings
[~, thisFileName, ~] = fileparts(mfilename('fullpath'));
narginTrue = nargin(thisFileName);   
narginchk(narginTrue, narginTrue);

%% Change the length units  
xSou1  = u2u(xSou,       units.length.processing, units.length.display);   % source grids
ySou1  = u2u(ySou,       units.length.processing, units.length.display);
zSou1  = u2u(zSou,       units.length.processing, units.length.display);
xRec1  = u2u(xRec,       units.length.processing, units.length.display);   % receivers
xWell1 = u2u(xWell,      units.length.processing, units.length.display);   % observation well
Resid  = u2u(timeRes,    units.time.processing,   units.time.display);     % time residuals
dTrms  = u2u(timeResMax, units.time.processing,   units.time.display);     % max time for plotting

%% Setup for plotting
figure(fig);   set(fig, 'Position', figPosition);   % 'setFigure' is not used to control the grid
minResidual = min(min(Resid));                      % threshold for plotting the misfit  
[i0,j0] = find(Resid == minResidual);
SensTol = minResidual + dTrms;  
Res = SensTol*ones(size(Resid));                    % make the plane white
indd = find(Resid < SensTol);                       % find indexes to be colored 
Res(indd) = Resid(indd);                            % color portion of the plane

% Define the plotting range in the coordinates whose origin corresponds to the top geophone 
coorOrig = xWell1;                              % set the coordinate origin to the well location
rrSou = sqrt((xSou1 - coorOrig(1)).^2 + (ySou1 - coorOrig(2)).^2);
zzSou = zSou1;     
rrRec = sqrt( ((xRec1(1,:) - coorOrig(1))*cos(azimSou)).^2 + ...
              ((xRec1(2,:) - coorOrig(2))*sin(azimSou)).^2 );   % azimSou is in rad
zzRec = xRec1(3,:);

hframe = 0.10;
Rbeg = min(rrRec);   Rend = max(max(rrSou));   ddR = hframe*(Rend - Rbeg);
Zbeg = min(zzRec);   Zend = max(max(zzSou));   ddZ = hframe*(Zend - Zbeg);

%% Plot the time residuals
whiteColor = [1 1 1];   lightgray = 0.7*whiteColor;    
%jet1 = jet;   jet2 = jet1(end:-1:1,:);                     % modify the colormap 

imagesc(rrSou(1,:), zzSou(:,1), Res);                       % plot the residuals
ch = colorbar('location', 'EastOutside');  
ylabel(ch, strcat('\Delta{\itt}_{RMS}  (', units.time.display, ')'), ...
        'Fontsize', figFontSize, 'Fontname', 'Times');
axis equal;      
axis([min(Rbeg, Rend) - ddR, max(Rbeg, Rend) + ddR, ...
      min([Zbeg, xRec1(3,:)]) - ddZ, max([Zend, xRec1(3,:)]) + ddZ]); 
colormap(gray);   hold on;    grid on;

%% Plot interfaces
xx = [0, 1.e+10];
if plotIntFlag == 1  
    noInt = size(interface,2);
    % Change the length units in representation of interfaces 
    interface1 = u2u(interface(1:3,:), units.length.processing, units.length.display);
    % Interface depth at the well location
    depthInt = planeDepth([interface1; interface(4:5,:)], xWell1, [1:noInt]);
    % Normal to the radial (plotting) plane
    nrmPln = [-sin(azimSou), cos(azimSou), 0]';

    for iint = 1:noInt
        % Normal to the interface
        nrmInt = interface(4:5,iint);
        nrmInt(3) = sqrt(1 - nrmInt(1)^2 - nrmInt(2)^2);
        % Parametric equation of an interface:  xxInt = x0Int + cross(nrmPln, nrmInt)*xx
        x0Int = [xWell1; depthInt(iint)];  
        xxInt = x0Int*ones(size(xx)) + cross(nrmPln, nrmInt)*xx;
        rrInt = sqrt((xxInt(1,:) - coorOrig(1)).^2 + (xxInt(2,:) - coorOrig(2)).^2);
        zzInt = xxInt(3,:);
        
        plot(rrInt, zzInt, 'LineWidth', 3, 'Color', colorInt);  % plot interface in 2D
    end;
end;

%% Place the geophones
if plotRecFlag == 1
    if plotWellFlag == 1
        line('XData', rrRec, 'YData', zzRec, 'Color', lightgray, 'LineWidth', 4);
    end;
    plot(rrRec, zzRec, '^', 'LineWidth', 1, 'MarkerSize', markerSizeRec, ...
          'MarkerEdgeColor', markerColorRec, 'MarkerFaceColor', markerColorRec); 
end;

%% Compute and plot the uncertainty ellipsoid

% Compute the 95% confidence interval in the radial plane
[x0Loc, A0Loc] = scatter2ellipse([rrSou(Resid < SensTol), ...
                                  zzSou(Resid < SensTol)], 'eig');
plotEllipse(fig, x0Loc, A0Loc, 0, colorEllipse, []);

% Transform uncertainties to global coordinates
x0 = u2u(x0Loc, units.length.display,   units.length.processing);  
A1 = u2u(A0Loc, units.length.processing, units.length.display);      % units of A are 
A0 = u2u(A1,    units.length.processing, units.length.display);      % [1/(units of x)^2]

% Rotation to global coordinates
rotLoc2Glob = [cos(azimSou), -sin(azimSou), 0; ...
               sin(azimSou),  cos(azimSou), 0; 0, 0, 1];
% Center of the uncertainty ellipsoid
x0Unc = rotLoc2Glob*[x0(1), 0, x0(2)]' + [xWell; 0];    
% Azimuthal uncertainty  
y0Unc = x0(1)*tan(azimSouStd);               
% Matrix A describing the 95% uncertainty ellipsoid as (x - x0Unc) * AUnc * (x - x0Unc)' = 1 
AUnc  = rotLoc2Glob*[A0(1,1), 0, A0(1,2); 0, 1/y0Unc^2, 0; A0(2,1), 0, A0(2,2)]*rotLoc2Glob';

% Eigenvectors and eigenvalues of the uncertainty ellipsoid in representation 
% AUnc = vUnc * diag(1./dUnc.^2) * vUnc' 
[vUnc, d] = eig(AUnc); 
dUnc = 1./sqrt(diag(d));

%% Mark the events and shots
if indexPerf(isou) == 1
    % Correct perforation-shot position
    plot(rrSou(i0(1),j0(1)), zzSou(i0(1),j0(1)), 'p', 'LineWidth', 1, ...
        'MarkerSize', markerSizePerf, 'MarkerEdgeColor', 'w', 'MarkerFaceColor', markerColorPerf);
elseif indexEvnt(isou) == 1
    plot(rrSou(i0(1),j0(1)), zzSou(i0(1),j0(1)), 'o', 'LineWidth', 1, ...
        'MarkerSize', markerSizeEvnt, 'MarkerEdgeColor', 'w', 'MarkerFaceColor', markerColorEvnt);
end;

set(gca, 'Fontsize', figFontSize, 'Fontname', 'Times'); 
xlabel(figXlabel);   ylabel(figYlabel);   
title(figTitle, 'Fontsize', 16, 'Fontname', 'Times');  
hold off;   drawnow;

end    % of the function