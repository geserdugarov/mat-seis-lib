%==================================================================================================
% Initialize the traveltime inversion 
% (*) This script needs to be tailored to each specific data set
% 
% function [param0, paramL, paramU, velBound] = ...
%     setInitGuess(dim, anisType, anisParam, ...
%                  unknCijInd, unknIntInd, unknFltInd, unknPrfInd, unknTauInd, ...
%                  xSou, xWell, noSou, indexPerf, indexEvnt, wellVec, tau); 
%
% Input: 
%   dim        - [scalar] dimension of the source-location problem 
%                dim = 2 when events are located in the vertical planes specified by the azimuths
%                of the P-wave polarization vectors and 
%                dim = 3 for full 3D event-location procedure  
%   anisType   - [noLayer, 3][char] array indicating the layer symmetry:
%                'ISO' - isotropy 
%                'VTI' - transverse isotropy; the symmetry axis can be tilted
%                'ORT' - orthotropy; the symmetry planes can be arbitrarily rotated 
%                'MNC' - monoclinic medium with a horizontal symmetry plane; subsequent rotation
%                        is possible
%                'TRI' - triclinic symmetry
%   anisParam  - [noLayer, 3] character array whose rows are equal to 'Cij' or 'Ani' to indicate 
%                whether the unknowns are stiffnesses or anisotropy coefficients
%   unknCijInd - [noLayer, 21] index array for the elastic parameters
%   unknIntInd - [5, noInt] index array for the interfaces
%   unknFltInd - [5, noFlt] index array for the interfaces
%   unknPrfInd - [1, noSou] index array for the perforations
%   unknTauInd - [1, noSou] index array for the origin times
%                Arrays unknCijInd, unknIntInd, unknFltInd, unknPrfInd, and unknTauInd 
%                are generated by 'setUnknowns'                 
%   xSou       - [3, noSou] array of the source coordinates
%   xWell      - [2, 1] vector of lateral coordinates of a horizontal well in which receivers
%                are located (irrelevant if dim = 3)
%   noSou      - the number of sources
%   indexPerf  - [1, noSou] array of ones and zeros 
%                Ones in indexPerf correspond to coordinates of the perforation shots in xSou
%   indexEvnt  - [1, noSou] array of ones and zeros 
%                Ones in indexEvnt correspond to coordinates of the microseismic events in xSou
%   wellVec    - [3, 1] vector of the well direction along which the velocities are constrainted,
%                presumably by the available sonic logs
%
% Output:
%   param0     - [1, noUnkn] array of the unknown parameters defined in 'specifyUnknowns'
%       noUnkn = length(find(unknCijInd == 0)) + length(find(unknIntInd == 0)) ...
%              + length(find(unknFltInd == 0)) + dim*length(find(unknPrfInd == 0)) + noSou
%   paramL     - [1, noUnkn] array of the lower bounds on the unknowns
%   paramU     - [1, noUnkn] array of the upper bounds on the unknowns
%   velBound   - [noLayer, 4] array of the minimum and maximum P- and S-wave velocities in layers
%                velBound(ilayer,:) = [VSmin, VSmax, VPmin, VPmax]
%                A NaN value of velBound(ilayer,i) implies an undefined bound 
%
% Copyright (C) Vladimir Grechka 2012
%==================================================================================================

%%
function [inversion] = setInitGuess(dim, model, unknowns)
%% Settings 
[~, thisFileName, ~] = fileparts(mfilename('fullpath'));
narginTrue = nargin(thisFileName);   
narginchk(narginTrue, narginTrue);

% Unpack 'model' structure
anisType = model.anisType;     anisParam = model.anisParam;
noSou = model.noSou;           xSou = model.xSou;            xWell = model.xWell;   
indexPerf = model.indexPerf;   indexEvnt = model.indexEvnt;   
wellVec = model.wellVec;       tau = model.tau;

% Unpack 'unknowns' structure
unknCijInd = unknowns.CijInd;
unknIntInd = unknowns.interfaceInd;
unknFltInd = unknowns.faultInd;
unknPrfInd = unknowns.perfInd;
unknTauInd = unknowns.tauInd;

%% Specify the bounds
boundsC = 0.2;          % percentage bound for Cij
boundsV = 0.1;          % percentage bound for velocities
boundsAL = -0.1;        % bound for anisotropy coefficients
boundsAU =  0.4;        % bound for anisotropy coefficients
boundsA = 30;           % bound for the rotation angles (deg) of the Cij
boundsP = 1.e-3;        % bound for the distances (procLengthUnits) of perforation shots 
boundsE = 0.2;         % bound for the distances (procLengthUnits) of microseismic events
boundsD = 0.02;         % bound for the interface and fault depths (procLengthUnits)  
boundsN = 0.05;         % bound for components of the and fault interface normals
boundsT = 0.05;          % bound for the origin times (procTimeUnits)

if ~(dim == 2 || dim == 3)   
    fprintf('\n>>> Function ''%s'' \n', functionInfo.file);
    fprintf('>>> Incorrect dimension of the even-location problem dim = %g \n', dim);
    fprintf('>>> The correct values are dim = 2 or dim = 3 -- STOP \n \n');  
      error(' ');
end;

%% Initialize parameters for the stiffnesses, interfaces, and faults
[Cij0Rot, Cij0, rotAngle, ~, ~, ~] = setCij(anisType);
[interface0, ~] = setInterface;
[fault0, ~] = setFault;

%% Initial guess and bounds for the elastic parameters
[v2m, ~, ~, ~] = indexesVMT(1);  
count = 0;
for ilayer=1:size(anisType, 1)
    clear indSym param1 param2
    % Determine the layer symmetry (see the 'v2m' conversion rule in 'indexesVMT')
    if strcmp(anisType(ilayer,:), 'ISO') == 1
        indSym = [1 16];
    elseif strcmp(anisType(ilayer,:), 'VTI') == 1
        indSym = [1 3 12 16 21];
    elseif strcmp(anisType(ilayer,:), 'ORT') == 1
        indSym = [1 2 3 7 8 12 16 19 21];
    elseif strcmp(anisType(ilayer,:), 'MNC') == 1
        indSym = [1 2 3 6 7 8 11 12 15 16 19 21];
    elseif strcmp(anisType(ilayer,:), 'TRI') == 1
        indSym = [1:21];
    else
        fprintf('\n>>> Function ''%s'' \n', functionInfo.function);
        fprintf('>>> Incorrect value of anisType = %s in layer %g -- STOP \n', ...
                anisType(ilayer,:), ilayer);
        error(' ');
    end;
    
    indUnkn = find(unknCijInd(ilayer,1:length(indSym)) == 0);       % indexes of the unknown 
    noUnknCij = length(indUnkn);                                    % elastic parameters

    % Initial guesses and bounds for the elastic parameters
    if noUnknCij > 0
        if strcmp(anisParam(ilayer,:), 'Cij') == 1
            for i=1:noUnknCij
                param0(count + i) = Cij0(v2m(1,indSym(indUnkn(i))), ...
                                         v2m(2,indSym(indUnkn(i))), ilayer);
            end;
            [param1, param2] = setBoundsCij(Cij0(:,:,ilayer), indSym(indUnkn), ...
                                            boundsC*[1, 1, 1, 0.5, 0.5]);
        
            paramL((count + 1) : (count + noUnknCij)) = ...
            param0((count + 1) : (count + noUnknCij)) + param1;
            paramU((count + 1) : (count + noUnknCij)) = ...
            param0((count + 1) : (count + noUnknCij)) + param2;

        elseif strcmp(anisParam(ilayer,:), 'Ani') == 1
            % Get the anisotropy coefficients
            aniMNC = cij2grechka(Cij0(:,:,ilayer));
            
            % Arrays for the anisotropy coefficients
            clear aniCoef
            if strcmp(anisType(ilayer,:), 'ISO') == 1
                aniCoef = aniMNC(1:2);
            elseif strcmp(anisType(ilayer,:), 'VTI') == 1
                aniCoef = [aniMNC(1:3), aniMNC(5), aniMNC(8)]; 
            elseif strcmp(anisType(ilayer,:), 'ORT') == 1
                aniCoef = aniMNC(1:9); 
            elseif strcmp(anisType(ilayer,:), 'MNC') == 1
                aniCoef = aniMNC(1:12); 
            else 
                fprintf('\n>>> Function ''%s'' \n', functionInfo.function);
                fprintf(strcat('>>> Anisotropy coefficients are undefined in layer %g ', ...
                               ' characterized by  anisType = %s \n'), ilayer, anisType(ilayer,:));
                fprintf(strcat('>>> Change anisType to ISO, VTI, ORT or MNC ', ...
                               ' or switch to the investion in terms of Cij''s -- STOP \n \n'));
                  error(' ');
            end;
            
            for i=1:noUnknCij
                if indUnkn(i) <= 2
                    param0(count + i) = aniCoef(indUnkn(i));                % velocities
                    paramL(count + i) = param0(count + i)*(1 - boundsV);    
                    paramU(count + i) = param0(count + i)*(1 + boundsV);
                else
                    param0(count + i) = aniCoef(indUnkn(i));               % anisotropy coef
%                    param0(count + i) = 0;              % always start inversion with isotropy
                    paramL(count + i) = boundsAL;
                    paramU(count + i) = boundsAU;
                end;
            end;
                                     
        else
            fprintf('\n>>> Function ''%s'' \n', functionInfo.function);
            fprintf('>>> Incorrect value of anisParam = %s in layer %g -- STOP \n \n', ...
                    anisParam(ilayer,:), ilayer);
              error(' ');
        end;                             
    end;
    count = count + noUnknCij;
    
    %----------------------------------------------------------------------------------------------
    if strcmp(anisType(ilayer,:), 'TRI') == 0
        % Find indexes of the unknown rotation angles
        ijUnknRot = find(unknCijInd(ilayer, (length(indSym)+1) : (length(indSym)+3)) == 0);
        noUnknRot = length(ijUnknRot);
    
        % Assign the initial guess and the bounds to the rotation angles
        if noUnknRot > 0
            for i=1:noUnknRot
                param0(count + i) = rotAngle(ijUnknRot(i),ilayer);
                paramL(count + i) = param0(count + i) - u2u(boundsA, 'deg', 'rad');
                paramU(count + i) = param0(count + i) + u2u(boundsA, 'deg', 'rad');
            end;
        end;
        count = count + noUnknRot;
    end;
    
    %----------------------------------------------------------------------------------------------
    % Set the bounds for velocity along a well
    velBound(ilayer,:) = NaN(1,4);
    if dim == 2
        [Vph, ~] = velPhaseU(Cij0Rot(:,:,ilayer), wellVec/norm(wellVec));
        velBound(ilayer,:) = [(1 - boundsV)*Vph(3), (1 + boundsV)*Vph(2), ...
                              (1 - boundsV)*Vph(1), (1 + boundsV)*Vph(1)];
    end;
end;
    
%% Initial guess and bounds for the coordinates of microseismic events and perforation shots 
for i=1:noSou
    if unknPrfInd(i) == 0
        clear bounds
        if indexPerf(i) == 1;
            bounds = boundsP;
        elseif indexEvnt(i) == 1
            bounds = boundsE;
        else
            fprintf('\n>>> Function ''%s'' \n', functionInfo.function);
            indexPerf
            indexEvnt
            fprintf('>>> Indexes in ''indexPerf'' and ''indexEvnt'' are inconsistent -- STOP \n');
              error(' ');
        end;
        
        if dim == 2
            param0((count + 1) : (count + 2)) = [sqrt( (xSou(1,i) - xWell(1))^2 + ...
                                                       (xSou(2,i) - xWell(2))^2 ), xSou(3,i)];
        else
            param0((count + 1) : (count + 3)) = xSou(:,i)';
        end;
        
        paramL((count + 1) : (count + dim)) = ...
        param0((count + 1) : (count + dim)) - bounds*ones(1,dim); 
        paramU((count + 1) : (count + dim)) = ...
        param0((count + 1) : (count + dim)) + bounds*ones(1,dim); 
        count = count + dim;
    end;
end;

%% Initial guess and bounds for interfaces
[irow1, icol1] = find(unknIntInd == 0);
for i=1:length(irow1)
    clear bounds
    if irow1(i) == 3
        bounds = boundsD;       % interface depth
    else
        bounds = boundsN;
    end;
    
    param0(count + i) = interface0(irow1(i), icol1(i));
    paramL(count + i) = param0(count + i) - bounds;
    paramU(count + i) = param0(count + i) + bounds;
end;
count = count + length(irow1);

%% Initial guess and bounds for faults
[irow2, icol2] = find(unknFltInd == 0);
for i=1:length(irow2)
    clear bounds
    if irow2(i) == 3
        bounds = boundsD;       % fault depth
    else
        bounds = boundsN;
    end;
    
    param0(count + i) = fault0(irow2(i), icol2(i));
    paramL(count + i) = param0(count + i) - bounds;
    paramU(count + i) = param0(count + i) + bounds;
end;
count = count + length(irow2);

%% Initial guess and bounds for origin times
if nargin < 14;    tau = zeros(1, noSou);   end;
for isou=1:noSou
    if unknTauInd(isou) == 0
        count = count + 1;
        param0(count) = tau(isou);
        paramL(count) = param0(count) - boundsT;
        paramU(count) = param0(count) + boundsT;
    end;
end;

%% Populate the output structure
inversion.paramInit = param0; 
inversion.paramLB   = paramL;
inversion.paramUB   = paramU; 
inversion.velBound  = velBound;

end    % of the function

